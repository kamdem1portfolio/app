name: Django CI/CD

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:

  # -----------------------------------------------
  # Job 1 : CI 
  # -----------------------------------------------
  ci:
    runs-on: ubuntu-latest

    env:
      NETWORK_NAME: github-ci-network
      POSTGRES_IMAGE: postgres:15
    
    steps:
      # 1Ô∏è‚É£ Checkout code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2Ô∏è‚É£ Set up Python
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11

      # 3Ô∏è‚É£ Linting avec pylint
      - name: Lint code with pylint
        run: |
          pip install pylint
          pylint $(git ls-files '*.py') --fail-under=3 --exit-zero

      # 4Ô∏è‚É£ SAST avec Bandit
      - name: Security check with Bandit
        run: |
          pip install bandit
          bandit -r . || true

      # 5Ô∏è‚É£ Set up Docker
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 6Ô∏è‚É£ Build Docker image
      - name: Build Docker image
        run: |
          docker build -t ${{ secrets.IMAGE_NAME }}:latest .

      # 7Ô∏è‚É£ Scan Docker image avec Trivy
      - name: Scan Docker image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ secrets.IMAGE_NAME }}:latest
          format: 'table'
          exit-code: '0' # ‚úÖ CI continue m√™me si vuln√©rabilit√©s d√©tect√©es. Si je veux bloquer en cas de pb, je dois mettre 1.
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
      
      # 7Ô∏è‚É£ Create Docker network
      - name: Create Docker network
        run: |
          docker network create ${{ env.NETWORK_NAME }}

      # 7Ô∏è‚É£ Start Postgres container on network
      - name: Start Postgres container on network
        run: |
          docker run -d --name ci_postgres \
            --network ${{ env.NETWORK_NAME }} \
            -e POSTGRES_DB=${{ secrets.DB_NAME }} \
            -e POSTGRES_USER=${{ secrets.DB_USER }} \
            -e POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }} \
            ${{ env.POSTGRES_IMAGE }}

      # 7Ô∏è‚É£ Wait for Postgres to become ready
      - name: Wait for Postgres to become ready
        run: |
          echo "Waiting for Postgres to be ready..."
          # use pg_isready inside the postgres container
          until docker exec ci_postgres pg_isready -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" >/dev/null 2>&1; do
            echo "Postgres not ready yet - sleeping 2s"
            sleep 2
          done
          echo "Postgres is ready."

      # 7Ô∏è‚É£ Start application container (detached, keep alive)
      - name: Start application container (detached, keep alive)
        run: |
          docker run -d --name app_container \
            --network ${{ env.NETWORK_NAME }} \
            --entrypoint "" \
            -e DB_HOST=ci_postgres \
            -e DB_PORT=5432 \
            -e DB_NAME=${{ secrets.DB_NAME }} \
            -e DB_USER=${{ secrets.DB_USER }} \
            -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
            -e SECRET_KEY=${{ secrets.SECRET_KEY }} \
            -e STRIPE_PUBLISHABLE_KEY=${{ secrets.STRIPE_PUBLISHABLE_KEY }} \
            -e STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }} \
            -e STRIPE_COUPON_ID_PERCENT=${{ secrets.STRIPE_COUPON_ID_PERCENT }} \
            ${{ secrets.IMAGE_NAME }}:latest sleep infinity

      # 7Ô∏è‚É£ Apply migrations (inside container)
      - name: Apply migrations (inside container)
        run: |
          echo "Running migrations..."
          docker exec app_container python manage.py migrate --noinput

      # 7Ô∏è‚É£ Run Django tests
      - name: Run Django tests
        run: |
          echo "Running tests..."
          docker exec app_container python manage.py test users store # order

      # üîü Healthcheck app
      - name: Check Django health
        run: |
          docker exec app_container python manage.py check

      # 2Ô∏è‚É£ Login Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 1Ô∏è‚É£1Ô∏è‚É£ Tag and push Docker image (release)
      - name: Tag & push Docker image
        if: github.ref == 'refs/heads/main'
        run: |
          IMAGE_NAME=${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_REPO }}
          TAG=v1.0.${{ github.run_number }}
          docker tag $IMAGE_NAME:latest $IMAGE_NAME:$TAG
          docker push $IMAGE_NAME:latest
          docker push $IMAGE_NAME:$TAG

  # -----------------------------------------------
  # Job 2 : CD (d√©livery in stagging Heroku + DAST)
  # -----------------------------------------------
  cd:
    runs-on: ubuntu-latest
    needs: ci
    steps:
      # 1Ô∏è‚É£ Checkout code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2Ô∏è‚É£ Login Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 3Ô∏è‚É£ Login Heroku Registry
      - name: Login to Heroku Container Registry
        run: |
          echo ${{ secrets.HEROKU_API_KEY }} | docker login --username=_ --password-stdin registry.heroku.com

      # 4Ô∏è‚É£ Pull l'image depuis Docker Hub
      - name: Pull image from Docker Hub
        run: |
          docker pull ${{ secrets.DOCKER_USERNAME }}/django-test-ci:latest

      # 5Ô∏è‚É£ Retagger pour Heroku
      - name: Tag image for Heroku
        run: |
          docker tag ${{ secrets.DOCKER_USERNAME }}/django-test-ci:latest \
            registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web

      # 6Ô∏è‚É£ Push vers Heroku
      - name: Push image to Heroku
        run: |
          docker push registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web

      # 7Ô∏è‚É£ Release sur Heroku
      - name: Release app
        run: |
          heroku container:release web -a ${{ secrets.HEROKU_APP_NAME }}
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}

      # 8Ô∏è‚É£ Configuration explicite de la DB
      - name: Set database config on Heroku
        run: |
          heroku config:set \
            DB_HOST=${{ secrets.DB_HOST }} \
            DB_PORT=${{ secrets.DB_PORT }} \
            DB_USER=${{ secrets.DB_USER }} \
            DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
            DB_NAME=${{ secrets.DB_NAME }} \
            -a ${{ secrets.HEROKU_APP_NAME }}
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}

      # 9Ô∏è‚É£ Scan DAST avec OWASP ZAP
      - name: Run DAST with OWASP ZAP
        run: |
          docker run --network="host" -t ghcr.io/zaproxy/zaproxy:stable zap-baseline.py \
            -t "https://${{ secrets.HEROKU_APP_NAME }}.herokuapp.com" \
            -r zap_report.html

  # -----------------------------------------------
  # Job 3 : CD (Deploiement)
  # -----------------------------------------------